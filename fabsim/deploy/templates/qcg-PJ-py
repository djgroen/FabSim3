#!/usr/bin/env python3
"""
FabSim3 QCG-PilotJob manager script - automatically generated
Controls the execution of tasks through QCG-PilotJob
"""
import sys
import logging
import traceback

from qcg.pilotjob.api.manager import LocalManager
from qcg.pilotjob.api.job import Jobs

# Set up logging
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)

try:
    # Initialize QCG-PilotJob manager
    logging.info("Initializing QCG-PilotJob LocalManager")
    manager = LocalManager()
        
    # Print available resources
    resources = manager.resources()
    logging.info(f"Available resources: {resources}")

    # Create jobs collection
    jobs = Jobs()

    # Add all task jobs from FabSim3
    logging.info("Adding job descriptions to QCG-PilotJob")

    # TASK DESCRIPTION BLOCK START - DO NOT MODIFY THESE LINES
$JOB_DESCRIPTIONS
    # TASK DESCRIPTION BLOCK END

    # Submit jobs and get their IDs
    logging.info("Submitting jobs to QCG-PilotJob")
    try:
        ids = manager.submit(jobs)
        logging.info(f"Submitted {len(ids)} jobs: {ids}")
    except Exception as submit_error:
        logging.error(f"Error submitting jobs: {str(submit_error)}")
        logging.error(traceback.format_exc())
        raise

    # Wait for all jobs to complete
    logging.info("Waiting for jobs to complete...")
    try:
        manager.wait4(ids)
    except Exception as wait_error:
        logging.error(f"Error waiting for jobs: {str(wait_error)}")
        logging.error(traceback.format_exc())
        raise
    
    # Get job information
    try:
        job_info = manager.info(ids)
        logging.info("Jobs completed with the following details:")
        for job_id, details in job_info.items():
            status = details.get('status', 'UNKNOWN')
            exit_code = details.get('exit_code', 'N/A')
            logging.info(f"Job {job_id}: Status={status}, Exit Code={exit_code}")
    except Exception as info_error:
        logging.error(f"Error getting job info: {str(info_error)}")
        logging.error(traceback.format_exc())

    try:
        total_core_seconds = 0
        for details in job_info.values():
            cores = details.get('resources', {}).get('cores', 0)
            start = details.get('start_time')
            end = details.get('end_time')

            if isinstance(start, (int, float)) and isinstance(end, (int, float)):
                duration = end - start
                total_core_seconds += duration * cores

        core_hours = total_core_seconds / 3600
        logging.info(f"Estimated total core-hours used: {core_hours:.2f}")
    except Exception as e:
        logging.warning(f"Failed to compute core-hours: {e}")
    
    # Clean up
    logging.info("All jobs completed, shutting down QCG-PilotJob manager")
    try:
        manager.finish()
    except Exception as cleanup_error:
        logging.error(f"Error during cleanup: {str(cleanup_error)}")
        logging.error(traceback.format_exc())
    
    # Final status report
    try:
        success_count = sum(1 for job in job_info.values() if job.get('status') == 'FINISHED' and job.get('exit_code') == 0)
        logging.info(f"Summary: {success_count}/{len(ids)} tasks completed successfully")
    except Exception as summary_error:
        logging.error(f"Error generating summary: {str(summary_error)}")
        logging.error(traceback.format_exc())
    
    sys.exit(0 if success_count == len(ids) else 1)
    
except Exception as e:
    logging.error(f"Error in QCG-PilotJob execution: {str(e)}")
    logging.error(traceback.format_exc())
    
    sys.exit(1)
