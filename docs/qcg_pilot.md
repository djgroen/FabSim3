# QCG Pilot-Job on Remote Machines

QCG Pilot Job is a lightweight implementation of the Pilot Job mechanism which
can be used to run a very large number of jobs efficiently on remote clusters and supercomputers.

More information on QCG-PilotJob can be found on their [ReadTheDocs site](https://qcg-pilotjob.readthedocs.io/en/develop/).

<p align="center">
    <img src="../images/qcg-pj.png" alt="Image of a QCG Pilot Job container" width="800" />
</p>
*Example of a QCG-Pilotjob container, which dynamically facilitates a diverse set of code executions within a single queuing system job. [link](https://link.springer.com/chapter/10.1007/978-3-030-77977-1_39)*

## Quick Start

### 1. Setup FabSim3

```bash
git clone https://github.com/djgroen/FabSim3.git
cd FabSim3
python3 configure_fabsim.py
```

**Recommended**: python3 is your System Python (typically `/usr/bin/python3`)

### 2. Create Virtual Environment

```bash
fabsim <machine> create_virtual_env
```

### 3. Install QCG-PilotJob

```bash
fabsim <machine> direct_install_app:QCG-PilotJob,venv=true
```

### 4. Update Configuration

Add the virtual environment path to your `machines_user.yml`:

```yaml
<machine>:
  virtual_env_path: "/path/to/your/virtual/environment"
```

(e.g., virtual_env_path: "/work/d202/d202/mzr234/VirtualEnv")

### 5. Test Installation

```bash
fabsim localhost install_plugin:FabDummy
fabsim localhost dummy_ensemble:dummy_test,pj_type=qcg,venv=true
```

## Resource Configuration

Configure your machine resources in `machines_user.yml`:

```yaml
<machine>:
  cores: 256            # Total cores to request
  corespernode: 128     # Cores per node (hardware specific)
  cpuspertask: 2        # Cores per individual task
  taskspernode: 64      # Calculated: 128 ÷ 2 = 64
```

This example creates **128 parallel tasks** across **2 nodes**:

- Node 1: 64 tasks × 2 cores = 128 cores
- Node 2: 64 tasks × 2 cores = 128 cores
- Total: 128 tasks using 256 cores

## Usage Examples

### Basic Ensemble

```bash
fabsim <machine> <app>_ensemble:<config>,pj_type=qcg,venv=true
```

### With Replicas

```bash
fabsim <machine> <app>_ensemble:<config>,replicas=5,pj_type=qcg,venv=true
```

### Large Scale Example

```bash
fabsim archer2 dummy_ensemble:dummy_test,replicas=128,cores=256,pj_type=qcg,venv=true
```

### Custom Resource Allocation

```bash
fabsim <machine> <app>_ensemble:<config>,cores=512,cpuspertask=4,job_wall_time=2:00:00,pj_type=qcg,venv=true
```

## Key Parameters

| Parameter | Description | Example |
|-----------|-------------|---------|
| `pj_type=qcg` | Enable QCG-PilotJob | Required |
| `venv=true` | Use virtual environment | Recommended |
| `cores=N` | Total cores to allocate | `cores=512` |
| `cpuspertask=N` | Cores per task | `cpuspertask=4` |
| `replicas=N` | Run each task N times | `replicas=1` |
| `job_wall_time=H:M:S` | Maximum job duration | `job_wall_time=2:00:00` |

The number of nodes will be calculated by FabSim3.

## Results

Fetch results after completion:

```bash
fabsim <machine> fetch_results
```

Results include:

- Individual task outputs in `RUNS/` subdirectories
- `QCG/` file with execution details
- SLURM job logs (`JobID-*.output`, `JobID-*.error`)
- QCG logs (`qcg_service.log`, `nl-agent-*.log`)

## Refine with Upsampling

Upsampling allows you to selectively increase the number of replicas for specific ensemble runs that show high variability. Instead of using resources excessively on uniformly replicating all runs, you focus only on cases where uncertainty is high.

### Complete Upsampling Workflow

### Step 1: Initial Broad Sweep

Run all parameter combinations with just one replica:

```bash
fabsim <machine> <app>_ensemble:<config>,replicas=1,pj_type=qcg,venv=true
```

This might generate 1000 runs like run_0001, run_0002, ..., run_1000, if there are 1000 subdirectories in the SWEEP directory.

### Step 2: Analyze Variability

After the first ensemble run, analyze your results manually or via a script to identify high-variance cases.

Example analysis results:

- run_0089: Parameter variance = 0.85 (HIGH), generated by d0089 in SWEEP directory
- run_0234: Parameter variance = 0.92 (HIGH), generated by d0234 in SWEEP directory
- run_0567: Parameter variance = 0.78 (HIGH), generated by d0567 in SWEEP directory

### Step 3: Targeted Upsampling

Add more replicas only to these high-variance cases:

```bash
fabsim <machine> <app>_ensemble:<config>,upsample="d0089;d0234;d0567",replicas=10,pj_type=qcg,venv=true
```

Each of the three runs above will be repeated 10 more times.

Comparison:

- Without upsampling: 10 x all = 10,000 jobs
- With upsampling: 1000 + (3 x 10) = 1,030 jobs

### Step 4: Flexible Replicas Per Run

Add various replicas ONLY to the high-variance cases:

```bash
fabsim <machine> <app>_ensemble:<config>,upsample="d0089;d0234;d0567",replicas="5;2;3",pj_type=qcg,venv=true
```

- d0089 → 5 replicas
- d0234 → 2 replicas
- d0567 → 3 replicas

### Step 5: Prioritizing with `exec_first`

```bash
fabsim <machine> <app>_ensemble:<config>,upsample="d0089;d0234;d0567",replicas="5;2;3",exec_first="d0567",pj_type=qcg,venv=true
```

d0567 will be prioritized in job execution order.

## Troubleshooting

**Common Issues:**

1. **"QCG not found"** → Check `virtual_env_path` in `machines_user.yml`
2. **Resource allocation errors** → Verify `cpuspertask ≤ corespernode`
3. **Job submission fails** → Check machine-specific SLURM parameters

**Debug Commands:**

```bash
# Check installation
fabsim <machine> direct_install_app:QCG-PilotJob,venv=True

# View job status
fabsim <machine> stat

# Check logs
fabsim <machine> fetch_results
```

## Supported Machines

QCG-PilotJob works on any SLURM-based HPC system. Pre-configured examples:

- ARCHER2 (UK National Supercomputing Service)
- Eagle (NREL HPC)
- Bridges-2 (Pittsburgh Supercomputing Center)

For other machines, configure the SLURM parameters in your `machine_user.yml`.
